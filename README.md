# Жадібні алгоритми та динамічне програмування

## Вступ
Цей проект реалізує дві функції для видачі решти покупцеві: `find_coins_greedy` і `find_min_coins`. Перша використовує жадібний алгоритм, а друга — динамічне програмування.

## Жадібний алгоритм: `find_coins_greedy`
Функція приймає суму і повертає словник із кількістю монет кожного номіналу, використовуючи найбільші доступні номінали.

### Приклад використання
```python
print(find_coins_greedy(113))  # {50: 2, 10: 1, 2: 1, 1: 1}
```
<br>

## Динамічне програмування: find_min_coins
Функція використовує метод динамічного програмування, щоб знайти мінімальну кількість монет для заданої суми.

### Приклад використання
```python
print(find_min_coins(113))  # {1: 1, 2: 1, 10: 1, 50: 2}
```

<br>

## Порівняння ефективності

### Жадібний алгоритм
* Часова складність: O(n), де n — кількість номіналів монет.
* Просторова складність: O(1), оскільки ми використовуємо постійну кількість додаткової пам'яті.
* Продуктивність: Жадібний алгоритм працює швидше і використовує менше пам'яті, але не завжди гарантує мінімальну кількість монет для деяких наборів монет.

### Динамічне програмування
* Часова складність: O(n⋅m), де n — кількість номіналів монет, m — сума.
* Просторова складність: O(m), де m — сума.
* Продуктивність: Алгоритм динамічного програмування гарантує мінімальну кількість монет, але працює повільніше і використовує більше пам'яті.

## Висновки
Жадібний алгоритм добре підходить для випадків, коли номінали монет дозволяють завжди обирати найбільші доступні монети, що призводить до оптимального рішення. Він працює швидше і потребує менше пам'яті.

Алгоритм динамічного програмування підходить для випадків, коли необхідно гарантувати мінімальну кількість монет незалежно від набору номіналів. Він є більш універсальним, але потребує більше часу і пам'яті.

